## 메모리 생존주기, 가비지 컬렉션

### 메모리란?

메모리는 쉽게 말해 **저장 공간**인데, 프로그램이 돌아가며 저장해야하는 **수많은 정보 및 데이터를 저장하는 공간**이라고 생각하자.

### 메모리를 왜 관리하나요?

알다시피 메모리는 **유한**하다.

유한한 공간을 효율적으로 사용하지 않으면, 그것이 곧 비용으로 나가게 되는 것이다.

---

### 자바스크립트에서 메모리 관리

메모리의 생존주기

```
필요할때 할당한다.

사용한다. (읽기, 쓰기)

필요없어지면 해제한다.
```

단순한 세단계로 나뉘어져있다.

자바스크립트도 역시,

**값을 선언할 때 자동으로 메모리를 할당한다.**

```
// 문자열 메모리 할당됨
const testStringValue = 'test';

// 정수 메모리 할당됨
const testNumberValue = 123;

...
```

---

<br />

**값을 사용하는 모든 일련의 과정에서 메모리를 사용**하게 된다.

```
// 메모리 할당
const testString = 'hello world';

// 메모리 사용 (읽기)
console.log(testString);
```

---

<br />

이제 **메모리가 쓰임을 다하면 해제하고 다시 사용 가능한 자원으로 회수**하게 되는데 이 시스템을, **가비지 컬렉션**이라하고 이 역할을 수행하는 프로그램이 **가비지 컬렉터**이다.

```
1.메모리는 '필요 없어졌을 때' 해제한다.

2.Javascript는 메모리 관리(해제 포함)을 가비지 콜렉터가 자동으로 해준다.

3.결국 메모리 해제 작업은 가비지 콜렉터가 진행 한다.
```

그럼 필요 없어졌을 때가 언제인가?

가비지 콜렉터가 **어떤 알고리즘으로 메모리를 해제시키는 지**에 대해 알아보자.

---

### 참조-세기 알고리즘

가비지 컬렉션 알고리즘의 핵심은 **참조**이다.

```
A라는 메모리를 통해 (명시적 혹은 암시적으로) B라는 메모리에 접근할 수 있을 때
"B는 A에 참조된다."라고 할 수 있다.
```

참조-세기 알고리즘은 현재 javascript에서 사용하지 않는 알고리즘이지만,

간단히 더이상 필요 없는 메모리(데이터) = **어떤 다른 메모리(데이터)도 참조하지 않는 메모리(데이터)** = 가비지(해체시켜!)

로 생각한다.

#### 왜 지금은 안사용할까?

바로 순환참조를 다루는 한계이다.

```
function test() {
  let firstValue = {};
  let secondValue = {};

  // 순환참조 구간
  firstValue.a = secondValue;
  secondValue.a = firstValue;

  return 'complete';
}

test();
```

이렇게 되면 firstValue와 secondValue가 서로 속성으로 참조하는 순환 구조를 보이고 있다.

서로 참조하고 있기 때문에 test() 함수가 실행되어 return으로 종료되면 객체들이 제거되지않고 계속 메모리를 가지고 있다. 이같은 현상이 **메모리 누수**를 야기시키게 된다.

---

### 표시하고-쓸기(Mark and sweep) 알고리즘

그래서 현재 javascript가 사용하는 가비지 컬렉션 알고리즘은 위 알고리즘이다.

필요없는 오브젝트를 참조당하지 않는 오브젝트가 아니라 **닿을 수 없는 오브젝트**로 정의하고 있다.

도달 가능성(reachability)이라고 하는 개념을 사용해 **도달 가능한(reachable)값을 판별**하는 알고리즘이다.

---

<br />

해당 알고리즘은 roots라는 오브젝트의 집합을 가지고 있다.

roots에 있는 **오브젝트 root에서 어떻게든 접근이 가능하다면 필요한 오브젝트(메모리)라고 판단**한다.

```
현재 함수의 지역 변수와 매개변수

중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수

전역 변수
```

위 예시들이 대표적인 root의 종류이다.

```
let user = {
  name : "joohyun"
};
```

현재 전역변수인 user가 {name: "joohyun"} 오브젝트를 참조하고 있는 모습이다.

근데 user의 값을 변경하게 되면 더이상 해당 오브젝를 참조하지 않게 되고 접근이 불가능하게 된다.

그럼 더이상 필요없는 오브젝트로 판단해 가비지 컬렉터가 메모리를 해제시켜버린다.

---

### 정리

- Javascript는 메모리 생명주기를 **가비지 컬렉션을 통해 자동으로 관리**해준다.

- 메모리 해제 과정에서 **표시하고-쓸기 알고리즘**을 사용한다.

- 이 알고리즘은 **객체가 도달 가능 한 상태가 아닐 때 메모리를 해제**시킨다.

- 가비지 컬렉션은 엔진이 자동으로 수행하므로, 개발자가 억지로 실행하거나 막을 수 없다.

---

### 출처

https://velog.io/@himprover/%EC%9D%B4%EC%A0%9C%EB%8A%94-%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EC%95%8C%EC%95%84%EC%95%BC%EC%A7%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%83%9D%EC%A1%B4%EC%A3%BC%EA%B8%B0-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98
